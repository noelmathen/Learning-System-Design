# 🧱 Single Responsibility Principle (SRP)

## 📘 Introduction

In software engineering, writing clean, scalable, and maintainable code is essential.

To achieve this, developers follow a set of five foundational object-oriented design guidelines known as the  **SOLID principles** .

> **S** in SOLID stands for  **Single Responsibility Principle (SRP)** .

---

## 🧩 Definition

> **A class should have only one reason to change.**

In simpler terms, a class should  **do one job and do it well** .

If a class handles multiple responsibilities, those responsibilities become tightly coupled — a change in one area might unintentionally break another.

This leads to a ripple effect of bugs and painful maintenance.

---

## 🍳 Real-Life Analogy

Imagine a chef who is responsible for  **cooking, cleaning, serving food, and ordering groceries** .

If the chef is busy cleaning, who’s cooking? The food quality drops.

Instead, assign each person one job:

| Role        | Responsibility     |
| ----------- | ------------------ |
| 👨‍🍳 Chef | Cooking            |
| 🧹 Cleaner  | Cleaning           |
| 🍽️ Waiter | Serving            |
| 🧾 Manager  | Ordering groceries |

When each person has a  **single focus** , everything runs more smoothly.

That’s exactly what SRP promotes in software —  **clarity and separation of concerns** .

---

## 💡 Example — TUF+ Compiler

Let’s take the example of a **TUF+ compiler** that currently does everything:

* Adds driver code
* Performs syntax checks
* Runs code with test cases
* Stores output in the database
* Returns results to the user

If all this logic sits in  **one giant `TUFplusCompiler` class** , that’s an SRP violation.

Instead, we can separate responsibilities into focused classes:

| Class                   | Responsibility                           |
| ----------------------- | ---------------------------------------- |
| `DriverCodeGenerator` | Adds driver code                         |
| `SyntaxChecker`       | Performs syntax validation               |
| `TestRunner`          | Executes code with test cases            |
| `DatabaseManager`     | Handles data storage                     |
| `UserOutputHandler`   | Sends response/output to user            |
| `Coordinator`         | Manages interactions between all modules |

This modular approach ensures that  **a change in one class doesn’t break the others** .

You can modify or extend each class independently.

---

## 🧠 Advantages of SRP

| Benefit                                 | Description                                                        |
| --------------------------------------- | ------------------------------------------------------------------ |
| **🛠️ Improved Maintainability** | Changing one module won’t affect others.                          |
| **📖 Enhanced Readability**       | Smaller, focused classes are easier to read and reason about.      |
| **♻️ Better Reusability**       | Independent classes can be reused elsewhere without extra baggage. |
| **🧪 Easier Testing**             | Testing becomes simpler as each class has fewer dependencies.      |
| **⚡ Lower Risk in Changes**      | Reduced side effects since each class has a single purpose.        |

---

## ⚠️ Common SRP Violations

| Mistake                                      | Description                                                                                           |
| -------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| **Mixing Database and Business Logic** | Combining SQL or persistence code with business rules in the same class makes future changes painful. |
| **Coupling UI and Business Logic**     | Putting application logic directly inside UI layers causes ripple effects when UI design changes.     |

---

## 🧭 Beyond Classes

> SRP isn’t just for classes — it’s a  **mindset** .

The same idea applies to:

* **Methods:** Each should do one well-defined task.
* **Modules:** Each should serve a clear functional purpose.
* **Microservices:** Each service should handle a single business capability.
* **Entire Systems:** Separate responsibilities across well-defined boundaries.

The guiding question remains the same:

> “Does this component have more than one reason to change?”

If the answer is yes, refactor until it doesn’t.

---

## 🧩 Summary

| Concept              | Explanation                                     |
| -------------------- | ----------------------------------------------- |
| **Definition** | A class should have only one reason to change.  |
| **Goal**       | Separation of concerns and modular design.      |
| **Result**     | Maintainable, testable, and clean architecture. |

---

## 🧰 Example Diagram (Conceptual Flow)

<pre class="overflow-visible!" data-start="4276" data-end="4672"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"><span><span>┌─────────────────────┐
│   Coordinator       │
│  (Orchestrates all) │
└─────────┬───────────┘
          │
 ┌────────┴────────┐
 │ DriverCodeGenerator │──► Adds driver code
 │ SyntaxChecker       │──► Validates code syntax
 │ TestRunner          │──► Executes test cases
 │ DatabaseManager     │──► Saves results
 │ UserOutputHandler   │──► Returns response
 └──────────────────────┘
</span></span></code></div></div></pre>

Each block handles one thing — and that’s the whole point.

---

## 🧾 Final Thought

The **Single Responsibility Principle** is the cornerstone of clean architecture.

It prevents chaos by enforcing **focus and clarity** in your design.

When every component does just one thing,

your system becomes easier to reason about, debug, and scale —

exactly what you’ll need when you’re building code for something as demanding as Google-level systems.
