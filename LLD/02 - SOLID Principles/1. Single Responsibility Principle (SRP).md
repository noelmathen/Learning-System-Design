# ğŸ§± Single Responsibility Principle (SRP)

## ğŸ“˜ Introduction

In software engineering, writing clean, scalable, and maintainable code is essential.

To achieve this, developers follow a set of five foundational object-oriented design guidelines known as the  **SOLID principles** .

> **S** in SOLID stands for  **Single Responsibility Principle (SRP)** .

---

## ğŸ§© Definition

> **A class should have only one reason to change.**

In simpler terms, a class should  **do one job and do it well** .

If a class handles multiple responsibilities, those responsibilities become tightly coupled â€” a change in one area might unintentionally break another.

This leads to a ripple effect of bugs and painful maintenance.

---

## ğŸ³ Real-Life Analogy

Imagine a chef who is responsible for  **cooking, cleaning, serving food, and ordering groceries** .

If the chef is busy cleaning, whoâ€™s cooking? The food quality drops.

Instead, assign each person one job:

| Role        | Responsibility     |
| ----------- | ------------------ |
| ğŸ‘¨â€ğŸ³ Chef | Cooking            |
| ğŸ§¹ Cleaner  | Cleaning           |
| ğŸ½ï¸ Waiter | Serving            |
| ğŸ§¾ Manager  | Ordering groceries |

When each person has a  **single focus** , everything runs more smoothly.

Thatâ€™s exactly what SRP promotes in software â€”  **clarity and separation of concerns** .

---

## ğŸ’¡ Example â€” TUF+ Compiler

Letâ€™s take the example of a **TUF+ compiler** that currently does everything:

* Adds driver code
* Performs syntax checks
* Runs code with test cases
* Stores output in the database
* Returns results to the user

If all this logic sits in  **one giant `TUFplusCompiler` class** , thatâ€™s an SRP violation.

Instead, we can separate responsibilities into focused classes:

| Class                   | Responsibility                           |
| ----------------------- | ---------------------------------------- |
| `DriverCodeGenerator` | Adds driver code                         |
| `SyntaxChecker`       | Performs syntax validation               |
| `TestRunner`          | Executes code with test cases            |
| `DatabaseManager`     | Handles data storage                     |
| `UserOutputHandler`   | Sends response/output to user            |
| `Coordinator`         | Manages interactions between all modules |

This modular approach ensures that  **a change in one class doesnâ€™t break the others** .

You can modify or extend each class independently.

---

## ğŸ§  Advantages of SRP

| Benefit                                 | Description                                                        |
| --------------------------------------- | ------------------------------------------------------------------ |
| **ğŸ› ï¸ Improved Maintainability** | Changing one module wonâ€™t affect others.                          |
| **ğŸ“– Enhanced Readability**       | Smaller, focused classes are easier to read and reason about.      |
| **â™»ï¸ Better Reusability**       | Independent classes can be reused elsewhere without extra baggage. |
| **ğŸ§ª Easier Testing**             | Testing becomes simpler as each class has fewer dependencies.      |
| **âš¡ Lower Risk in Changes**      | Reduced side effects since each class has a single purpose.        |

---

## âš ï¸ Common SRP Violations

| Mistake                                      | Description                                                                                           |
| -------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| **Mixing Database and Business Logic** | Combining SQL or persistence code with business rules in the same class makes future changes painful. |
| **Coupling UI and Business Logic**     | Putting application logic directly inside UI layers causes ripple effects when UI design changes.     |

---

## ğŸ§­ Beyond Classes

> SRP isnâ€™t just for classes â€” itâ€™s a  **mindset** .

The same idea applies to:

* **Methods:** Each should do one well-defined task.
* **Modules:** Each should serve a clear functional purpose.
* **Microservices:** Each service should handle a single business capability.
* **Entire Systems:** Separate responsibilities across well-defined boundaries.

The guiding question remains the same:

> â€œDoes this component have more than one reason to change?â€

If the answer is yes, refactor until it doesnâ€™t.

---

## ğŸ§© Summary

| Concept              | Explanation                                     |
| -------------------- | ----------------------------------------------- |
| **Definition** | A class should have only one reason to change.  |
| **Goal**       | Separation of concerns and modular design.      |
| **Result**     | Maintainable, testable, and clean architecture. |

---

## ğŸ§° Example Diagram (Conceptual Flow)

<pre class="overflow-visible!" data-start="4276" data-end="4672"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"><span><span>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Coordinator       â”‚
â”‚  (Orchestrates all) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ DriverCodeGenerator â”‚â”€â”€â–º Adds driver code
 â”‚ SyntaxChecker       â”‚â”€â”€â–º Validates code syntax
 â”‚ TestRunner          â”‚â”€â”€â–º Executes test cases
 â”‚ DatabaseManager     â”‚â”€â”€â–º Saves results
 â”‚ UserOutputHandler   â”‚â”€â”€â–º Returns response
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span></code></div></div></pre>

Each block handles one thing â€” and thatâ€™s the whole point.

---

## ğŸ§¾ Final Thought

The **Single Responsibility Principle** is the cornerstone of clean architecture.

It prevents chaos by enforcing **focus and clarity** in your design.

When every component does just one thing,

your system becomes easier to reason about, debug, and scale â€”

exactly what youâ€™ll need when youâ€™re building code for something as demanding as Google-level systems.
