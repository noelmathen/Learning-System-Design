# 🔗 Dependency Inversion Principle (DIP)

## 📘 Introduction

The **Dependency Inversion Principle (DIP)** is the final pillar of the **SOLID** design principles — a foundational set of guidelines for writing **clean, scalable, and maintainable** object-oriented code.

> **D** stands for  **Dependency Inversion Principle** .

---

## 🧱 Pre-requisites

To fully understand DIP, let’s first distinguish between two important types of modules:

| Term                         | Description                                                                                | Analogy                                                    |
| ---------------------------- | ------------------------------------------------------------------------------------------ | ---------------------------------------------------------- |
| **High-Level Modules** | Contain the**core logic**— the decision-makers that orchestrate the overall system. | CEO — makes strategies and big decisions.                 |
| **Low-Level Modules**  | Handle the**implementation details**— interacting with databases, APIs, or files.   | Employees — execute the plans and handle the actual work. |

And between them sits the hero of this principle:

> **Abstraction** — The contract or interface that allows high-level and low-level modules to communicate without knowing each other’s details.

---

## 🧩 Definition

> “High-level modules should not depend on low-level modules.
>
> Both should depend on abstractions.
>
> Abstractions should not depend on details.
>
> Details should depend on abstractions.”

In simpler terms:

* Don’t make your main logic (high-level module) depend directly on detailed implementations.
* Instead,  **connect them through interfaces or abstract classes** .

This creates  **flexible** ,  **testable** , and **maintainable** code.

---

## 🍕 Real-Life Analogy

Imagine you’re craving pizza. You use a **food delivery app** to order, not by calling the chef directly.

**You (User)** → use → **Food App (Abstraction)** → connects to → **Restaurant/Chef (Implementation)**

| Role               | In Software Terms |
| ------------------ | ----------------- |
| You                | High-Level Module |
| Food App Interface | Abstraction       |
| Restaurant         | Low-Level Module  |

You don’t care *how* the pizza is made or *who* the chef is — you just depend on the **abstraction** (the food app).

That’s exactly how DIP works: the high-level module doesn’t depend on the low-level module directly.

---

## 🎬 Example — Netflix Recommendation Engine

Netflix suggests content using different  **recommendation strategies** , such as:

* 🎞 **Recently Added**
* 🔥 **Trending Now**
* 🎭 **Genre-Based**

We’ll see how **bad design** violates DIP and how **good design** fixes it.

---

### ❌ Without DIP — Tightly Coupled Code

<pre class="overflow-visible!" data-start="2654" data-end="3044"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>// Low-level module</span><span>
</span><span>class</span><span></span><span>RecentlyAdded</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span> {
        System.out.println(</span><span>"Showing recently added content..."</span><span>);
    }
}

</span><span>// High-level module (depends directly on low-level)</span><span>
</span><span>class</span><span></span><span>RecommendationEngine</span><span> {
    </span><span>private</span><span></span><span>RecentlyAdded</span><span></span><span>recommender</span><span></span><span>=</span><span></span><span>new</span><span></span><span>RecentlyAdded</span><span>();

    </span><span>public</span><span></span><span>void</span><span></span><span>recommend</span><span>()</span><span> {
        recommender.getRecommendations();
    }
}
</span></span></code></div></div></pre>

#### ⚠️ Problems:

* The `RecommendationEngine` is **tightly coupled** to `RecentlyAdded`.
* To use a new strategy (like Trending or Genre), you must **modify the engine** — breaking the open/closed principle too.

---

### ✅ With DIP — Using Abstraction

Let’s introduce an **interface** that represents a generic recommendation strategy.

<pre class="overflow-visible!" data-start="3392" data-end="4589"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>// Abstraction</span><span>
</span><span>interface</span><span></span><span>RecommendationStrategy</span><span> {
    </span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span>;
}

</span><span>// Concrete strategies</span><span>
</span><span>class</span><span></span><span>RecentlyAdded</span><span></span><span>implements</span><span></span><span>RecommendationStrategy</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span> {
        System.out.println(</span><span>"Showing recently added content..."</span><span>);
    }
}

</span><span>class</span><span></span><span>TrendingNow</span><span></span><span>implements</span><span></span><span>RecommendationStrategy</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span> {
        System.out.println(</span><span>"Showing trending content..."</span><span>);
    }
}

</span><span>class</span><span></span><span>GenreBased</span><span></span><span>implements</span><span></span><span>RecommendationStrategy</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span> {
        System.out.println(</span><span>"Showing content based on your favorite genres..."</span><span>);
    }
}

</span><span>// High-level module depends on abstraction</span><span>
</span><span>class</span><span></span><span>RecommendationEngine</span><span> {
    </span><span>private</span><span> RecommendationStrategy strategy;

    </span><span>public</span><span></span><span>RecommendationEngine</span><span>(RecommendationStrategy strategy)</span><span> {
        </span><span>this</span><span>.strategy = strategy;
    }

    </span><span>public</span><span></span><span>void</span><span></span><span>recommend</span><span>()</span><span> {
        strategy.getRecommendations();
    }
}

</span><span>// Main driver</span><span>
</span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>RecommendationStrategy</span><span></span><span>strategy</span><span></span><span>=</span><span></span><span>new</span><span></span><span>TrendingNow</span><span>(); </span><span>// interchangeable</span><span>
        </span><span>RecommendationEngine</span><span></span><span>engine</span><span></span><span>=</span><span></span><span>new</span><span></span><span>RecommendationEngine</span><span>(strategy);
        engine.recommend();
    }
}
</span></span></code></div></div></pre>

---

### 🧠 Explanation

* `RecommendationEngine` (high-level) doesn’t care *how* recommendations are made — it just calls the interface method.
* `RecentlyAdded`, `TrendingNow`, and `GenreBased` are **low-level modules** implementing the same abstraction.
* Swapping strategies is effortless — no need to modify existing logic.

---

## 🔄 Switching Strategies at Runtime

Want to switch recommendation logic dynamically? No problem.

<pre class="overflow-visible!" data-start="5037" data-end="5224"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>RecommendationEngine</span><span></span><span>engine</span><span></span><span>=</span><span></span><span>new</span><span></span><span>RecommendationEngine</span><span>(</span><span>new</span><span></span><span>GenreBased</span><span>());
        engine.recommend();
    }
}
</span></span></code></div></div></pre>

You can replace one strategy with another instantly — without touching the engine’s source code.

---

## 🧰 Benefits of Using DIP

| Benefit                   | Description                                                     |
| ------------------------- | --------------------------------------------------------------- |
| **Flexibility**     | Easily swap implementations without modifying high-level logic. |
| **Testability**     | Use mock strategies during unit testing.                        |
| **Reusability**     | Components can be reused with different implementations.        |
| **Maintainability** | Changes in one module don’t ripple through the system.         |
| **Scalability**     | Extend or upgrade code effortlessly with new abstractions.      |

---

## ⚙️ Summary

| Concept                      | Description                                                                   |
| ---------------------------- | ----------------------------------------------------------------------------- |
| **High-Level Modules** | Contain core business logic (e.g.,`RecommendationEngine`).                  |
| **Low-Level Modules**  | Implement specific details (e.g.,`TrendingNow`,`RecentlyAdded`).          |
| **Abstractions**       | Interfaces or abstract classes connecting them (`RecommendationStrategy`).  |
| **DIP Goal**           | Make both high- and low-level modules depend on abstractions, not each other. |

---

## 🧩 Concept Diagram

<pre class="overflow-visible!" data-start="6289" data-end="7161"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"><span><span>             ┌──────────────────────────────┐
             │     RecommendationEngine     │
             │   (High-Level Module)        │
             └──────────────┬───────────────┘
                            │ depends on
                            ▼
                 ┌──────────────────────────┐
                 │   RecommendationStrategy │
                 │        (Abstraction)     │
                 └──────────────┬───────────┘
                                │
      ┌─────────────────────────┼──────────────────────────┐
      │                         │                          │
┌──────────────┐        ┌──────────────┐          ┌──────────────┐
│ RecentlyAdded│        │ TrendingNow │          │ GenreBased   │
│(Low-Level)   │        │(Low-Level)  │          │(Low-Level)   │
└──────────────┘        └──────────────┘          └──────────────┘
</span></span></code></div></div></pre>

Both high-level and low-level modules  **depend on abstractions** , never on each other directly.

---

## 🧾 Conclusion

The **Dependency Inversion Principle** flips the traditional dependency chain.

Instead of high-level modules relying on details,  **both sides rely on abstractions** .

This design makes your code:

* **Flexible**
* **Easier to test**
* **Less fragile**
* **Ready for change**

> In short: **Depend on interfaces, not implementations.**
>
> That’s how you build systems that adapt — not collapse — when requirements change.
>
