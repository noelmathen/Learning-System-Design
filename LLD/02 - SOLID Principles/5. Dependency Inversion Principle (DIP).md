# ğŸ”— Dependency Inversion Principle (DIP)

## ğŸ“˜ Introduction

The **Dependency Inversion Principle (DIP)** is the final pillar of the **SOLID** design principles â€” a foundational set of guidelines for writing **clean, scalable, and maintainable** object-oriented code.

> **D** stands for  **Dependency Inversion Principle** .

---

## ğŸ§± Pre-requisites

To fully understand DIP, letâ€™s first distinguish between two important types of modules:

| Term                         | Description                                                                                | Analogy                                                    |
| ---------------------------- | ------------------------------------------------------------------------------------------ | ---------------------------------------------------------- |
| **High-Level Modules** | Contain the**core logic**â€” the decision-makers that orchestrate the overall system. | CEO â€” makes strategies and big decisions.                 |
| **Low-Level Modules**  | Handle the**implementation details**â€” interacting with databases, APIs, or files.   | Employees â€” execute the plans and handle the actual work. |

And between them sits the hero of this principle:

> **Abstraction** â€” The contract or interface that allows high-level and low-level modules to communicate without knowing each otherâ€™s details.

---

## ğŸ§© Definition

> â€œHigh-level modules should not depend on low-level modules.
>
> Both should depend on abstractions.
>
> Abstractions should not depend on details.
>
> Details should depend on abstractions.â€

In simpler terms:

* Donâ€™t make your main logic (high-level module) depend directly on detailed implementations.
* Instead,  **connect them through interfaces or abstract classes** .

This creates  **flexible** ,  **testable** , and **maintainable** code.

---

## ğŸ• Real-Life Analogy

Imagine youâ€™re craving pizza. You use a **food delivery app** to order, not by calling the chef directly.

**You (User)** â†’ use â†’ **Food App (Abstraction)** â†’ connects to â†’ **Restaurant/Chef (Implementation)**

| Role               | In Software Terms |
| ------------------ | ----------------- |
| You                | High-Level Module |
| Food App Interface | Abstraction       |
| Restaurant         | Low-Level Module  |

You donâ€™t care *how* the pizza is made or *who* the chef is â€” you just depend on the **abstraction** (the food app).

Thatâ€™s exactly how DIP works: the high-level module doesnâ€™t depend on the low-level module directly.

---

## ğŸ¬ Example â€” Netflix Recommendation Engine

Netflix suggests content using different  **recommendation strategies** , such as:

* ğŸ **Recently Added**
* ğŸ”¥ **Trending Now**
* ğŸ­ **Genre-Based**

Weâ€™ll see how **bad design** violates DIP and how **good design** fixes it.

---

### âŒ Without DIP â€” Tightly Coupled Code

<pre class="overflow-visible!" data-start="2654" data-end="3044"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>// Low-level module</span><span>
</span><span>class</span><span></span><span>RecentlyAdded</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span> {
        System.out.println(</span><span>"Showing recently added content..."</span><span>);
    }
}

</span><span>// High-level module (depends directly on low-level)</span><span>
</span><span>class</span><span></span><span>RecommendationEngine</span><span> {
    </span><span>private</span><span></span><span>RecentlyAdded</span><span></span><span>recommender</span><span></span><span>=</span><span></span><span>new</span><span></span><span>RecentlyAdded</span><span>();

    </span><span>public</span><span></span><span>void</span><span></span><span>recommend</span><span>()</span><span> {
        recommender.getRecommendations();
    }
}
</span></span></code></div></div></pre>

#### âš ï¸ Problems:

* The `RecommendationEngine` is **tightly coupled** to `RecentlyAdded`.
* To use a new strategy (like Trending or Genre), you must **modify the engine** â€” breaking the open/closed principle too.

---

### âœ… With DIP â€” Using Abstraction

Letâ€™s introduce an **interface** that represents a generic recommendation strategy.

<pre class="overflow-visible!" data-start="3392" data-end="4589"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>// Abstraction</span><span>
</span><span>interface</span><span></span><span>RecommendationStrategy</span><span> {
    </span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span>;
}

</span><span>// Concrete strategies</span><span>
</span><span>class</span><span></span><span>RecentlyAdded</span><span></span><span>implements</span><span></span><span>RecommendationStrategy</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span> {
        System.out.println(</span><span>"Showing recently added content..."</span><span>);
    }
}

</span><span>class</span><span></span><span>TrendingNow</span><span></span><span>implements</span><span></span><span>RecommendationStrategy</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span> {
        System.out.println(</span><span>"Showing trending content..."</span><span>);
    }
}

</span><span>class</span><span></span><span>GenreBased</span><span></span><span>implements</span><span></span><span>RecommendationStrategy</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>getRecommendations</span><span>()</span><span> {
        System.out.println(</span><span>"Showing content based on your favorite genres..."</span><span>);
    }
}

</span><span>// High-level module depends on abstraction</span><span>
</span><span>class</span><span></span><span>RecommendationEngine</span><span> {
    </span><span>private</span><span> RecommendationStrategy strategy;

    </span><span>public</span><span></span><span>RecommendationEngine</span><span>(RecommendationStrategy strategy)</span><span> {
        </span><span>this</span><span>.strategy = strategy;
    }

    </span><span>public</span><span></span><span>void</span><span></span><span>recommend</span><span>()</span><span> {
        strategy.getRecommendations();
    }
}

</span><span>// Main driver</span><span>
</span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>RecommendationStrategy</span><span></span><span>strategy</span><span></span><span>=</span><span></span><span>new</span><span></span><span>TrendingNow</span><span>(); </span><span>// interchangeable</span><span>
        </span><span>RecommendationEngine</span><span></span><span>engine</span><span></span><span>=</span><span></span><span>new</span><span></span><span>RecommendationEngine</span><span>(strategy);
        engine.recommend();
    }
}
</span></span></code></div></div></pre>

---

### ğŸ§  Explanation

* `RecommendationEngine` (high-level) doesnâ€™t care *how* recommendations are made â€” it just calls the interface method.
* `RecentlyAdded`, `TrendingNow`, and `GenreBased` are **low-level modules** implementing the same abstraction.
* Swapping strategies is effortless â€” no need to modify existing logic.

---

## ğŸ”„ Switching Strategies at Runtime

Want to switch recommendation logic dynamically? No problem.

<pre class="overflow-visible!" data-start="5037" data-end="5224"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>RecommendationEngine</span><span></span><span>engine</span><span></span><span>=</span><span></span><span>new</span><span></span><span>RecommendationEngine</span><span>(</span><span>new</span><span></span><span>GenreBased</span><span>());
        engine.recommend();
    }
}
</span></span></code></div></div></pre>

You can replace one strategy with another instantly â€” without touching the engineâ€™s source code.

---

## ğŸ§° Benefits of Using DIP

| Benefit                   | Description                                                     |
| ------------------------- | --------------------------------------------------------------- |
| **Flexibility**     | Easily swap implementations without modifying high-level logic. |
| **Testability**     | Use mock strategies during unit testing.                        |
| **Reusability**     | Components can be reused with different implementations.        |
| **Maintainability** | Changes in one module donâ€™t ripple through the system.         |
| **Scalability**     | Extend or upgrade code effortlessly with new abstractions.      |

---

## âš™ï¸ Summary

| Concept                      | Description                                                                   |
| ---------------------------- | ----------------------------------------------------------------------------- |
| **High-Level Modules** | Contain core business logic (e.g.,`RecommendationEngine`).                  |
| **Low-Level Modules**  | Implement specific details (e.g.,`TrendingNow`,`RecentlyAdded`).          |
| **Abstractions**       | Interfaces or abstract classes connecting them (`RecommendationStrategy`).  |
| **DIP Goal**           | Make both high- and low-level modules depend on abstractions, not each other. |

---

## ğŸ§© Concept Diagram

<pre class="overflow-visible!" data-start="6289" data-end="7161"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"><span><span>             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚     RecommendationEngine     â”‚
             â”‚   (High-Level Module)        â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚ depends on
                            â–¼
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚   RecommendationStrategy â”‚
                 â”‚        (Abstraction)     â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                         â”‚                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RecentlyAddedâ”‚        â”‚ TrendingNow â”‚          â”‚ GenreBased   â”‚
â”‚(Low-Level)   â”‚        â”‚(Low-Level)  â”‚          â”‚(Low-Level)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span></code></div></div></pre>

Both high-level and low-level modules  **depend on abstractions** , never on each other directly.

---

## ğŸ§¾ Conclusion

The **Dependency Inversion Principle** flips the traditional dependency chain.

Instead of high-level modules relying on details,  **both sides rely on abstractions** .

This design makes your code:

* **Flexible**
* **Easier to test**
* **Less fragile**
* **Ready for change**

> In short: **Depend on interfaces, not implementations.**
>
> Thatâ€™s how you build systems that adapt â€” not collapse â€” when requirements change.
>
