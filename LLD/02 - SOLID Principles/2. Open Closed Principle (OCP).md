# ğŸ”’ Open/Closed Principle (OCP)

## ğŸ“˜ Introduction

The **Open/Closed Principle (OCP)** is the second principle in the **SOLID** set â€” five core guidelines for writing  **clean, scalable, and maintainable object-oriented code** .

> **O** stands for  **Open for Extension, Closed for Modification** .

This means your classes, modules, and functions should allow  **new functionality to be added without changing existing code** .

In short: extend behavior, donâ€™t rewrite it.

---

## ğŸ§© Definition

> **Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.**

The idea is to **minimize the risk of breaking existing functionality** when new features or rules are introduced.

---

## ğŸ”Œ Real-Life Analogy

Imagine you travel from **India** to the  **UK** .

Your Indian phone charger doesnâ€™t fit the UK power socket.

Instead of **modifying** the charger, you simply use a  **travel adapter** .

âœ… The adapter **extends** the chargerâ€™s usability.

âŒ You didnâ€™t have to **change** the charger itself.

Thatâ€™s exactly how OCP works in code â€” you extend functionality through  **extension (adapters, subclasses, strategies)** , not modification.

---

## ğŸ’¼ Real-World Example â€” Region-Based Tax Calculation

Letâ€™s say we have an **Invoicing System** that calculates regional taxes:

| Region | Tax Type  | Rate |
| ------ | --------- | ---- |
| India  | GST       | 18%  |
| US     | Sales Tax | 8%   |
| UK     | VAT       | 12%  |

As the business grows, new regions (like Germany or Japan) might be added.

---

### âŒ Bad Design â€” Violating OCP

<pre class="overflow-visible!" data-start="1830" data-end="2303"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>InvoiceProcessor</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTotal</span><span>(String region, double</span><span> amount) {
        </span><span>if</span><span> (region.equalsIgnoreCase(</span><span>"India"</span><span>)) {
            </span><span>return</span><span> amount + amount * </span><span>0.18</span><span>;
        } </span><span>else</span><span></span><span>if</span><span> (region.equalsIgnoreCase(</span><span>"US"</span><span>)) {
            </span><span>return</span><span> amount + amount * </span><span>0.08</span><span>;
        } </span><span>else</span><span></span><span>if</span><span> (region.equalsIgnoreCase(</span><span>"UK"</span><span>)) {
            </span><span>return</span><span> amount + amount * </span><span>0.12</span><span>;
        } </span><span>else</span><span> {
            </span><span>return</span><span> amount; </span><span>// No tax for unknown region</span><span>
        }
    }
}
</span></span></code></div></div></pre>

**Problems:**

* Adding a new region (e.g., Germany) means **editing** this class.
* High risk of breaking tested code.
* Hard to test and scale.
* Violates the  **Open/Closed Principle** .

---

### âœ… Good Design â€” Following OCP

Weâ€™ll use **interfaces** and **dependency injection** to make this design extensible.

<pre class="overflow-visible!" data-start="2628" data-end="4166"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>// Tax Strategy Interface</span><span>
</span><span>interface</span><span></span><span>TaxCalculator</span><span> {
    </span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount);
}

</span><span>// Implementing Region-Specific Tax Calculators</span><span>
</span><span>class</span><span></span><span>IndiaTaxCalculator</span><span></span><span>implements</span><span></span><span>TaxCalculator</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount) {
        </span><span>return</span><span> amount * </span><span>0.18</span><span>; </span><span>// GST</span><span>
    }
}

</span><span>class</span><span></span><span>USTaxCalculator</span><span></span><span>implements</span><span></span><span>TaxCalculator</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount) {
        </span><span>return</span><span> amount * </span><span>0.08</span><span>; </span><span>// Sales Tax</span><span>
    }
}

</span><span>class</span><span></span><span>UKTaxCalculator</span><span></span><span>implements</span><span></span><span>TaxCalculator</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount) {
        </span><span>return</span><span> amount * </span><span>0.12</span><span>; </span><span>// VAT</span><span>
    }
}

</span><span>// Invoice Class using Dependency Injection</span><span>
</span><span>class</span><span></span><span>Invoice</span><span> {
    </span><span>private</span><span></span><span>double</span><span> amount;
    </span><span>private</span><span> TaxCalculator taxCalculator;

    </span><span>public</span><span></span><span>Invoice</span><span>(double</span><span> amount, TaxCalculator taxCalculator) {
        </span><span>this</span><span>.amount = amount;
        </span><span>this</span><span>.taxCalculator = taxCalculator;
    }

    </span><span>public</span><span></span><span>double</span><span></span><span>getTotalAmount</span><span>()</span><span> {
        </span><span>return</span><span> amount + taxCalculator.calculateTax(amount);
    }
}

</span><span>// Main Class</span><span>
</span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>double</span><span></span><span>amount</span><span></span><span>=</span><span></span><span>1000.0</span><span>;

        </span><span>Invoice</span><span></span><span>indiaInvoice</span><span></span><span>=</span><span></span><span>new</span><span></span><span>Invoice</span><span>(amount, </span><span>new</span><span></span><span>IndiaTaxCalculator</span><span>());
        System.out.println(</span><span>"Total (India): â‚¹"</span><span> + indiaInvoice.getTotalAmount());

        </span><span>Invoice</span><span></span><span>usInvoice</span><span></span><span>=</span><span></span><span>new</span><span></span><span>Invoice</span><span>(amount, </span><span>new</span><span></span><span>USTaxCalculator</span><span>());
        System.out.println(</span><span>"Total (US): $"</span><span> + usInvoice.getTotalAmount());

        </span><span>Invoice</span><span></span><span>ukInvoice</span><span></span><span>=</span><span></span><span>new</span><span></span><span>Invoice</span><span>(amount, </span><span>new</span><span></span><span>UKTaxCalculator</span><span>());
        System.out.println(</span><span>"Total (UK): Â£"</span><span> + ukInvoice.getTotalAmount());
    }
}
</span></span></code></div></div></pre>

---

### ğŸ§  Explanation

* **Tax Strategy Interface:**

  Defines a common contract for all region-specific tax calculators.
* **Concrete Implementations:**

  Each region implements its own `TaxCalculator`, encapsulating its tax logic.
* **Dependency Injection:**

  The `Invoice` class depends on the `TaxCalculator` abstraction, not a specific implementation.
* **Extensibility:**

  To add a new region (e.g., Germany), simply create:

<pre class="overflow-visible!" data-start="4623" data-end="4774"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>GermanyTaxCalculator</span><span></span><span>implements</span><span></span><span>TaxCalculator</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount) {
        </span><span>return</span><span> amount * </span><span>0.15</span><span>;
    }
}
</span></span></code></div></div></pre>

Then inject it:

<pre class="overflow-visible!" data-start="4792" data-end="4877"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>Invoice</span><span></span><span>germanyInvoice</span><span></span><span>=</span><span></span><span>new</span><span></span><span>Invoice</span><span>(amount, </span><span>new</span><span></span><span>GermanyTaxCalculator</span><span>());
</span></span></code></div></div></pre>

No existing code needs to change. Thatâ€™s OCP in action.

---

## ğŸ§° When to Apply OCP

Use the **Open/Closed Principle** when:

* A moduleâ€™s behavior is expected to **evolve** frequently.
* You need to **extend functionality** without touching stable, tested code.
* Building **frameworks or plugin-based systems** (e.g., billing engines, tax systems, UI modules).
* Preventing **regression bugs** in production-ready components.
* You notice a **â€œGod Classâ€** â€” a class doing too many things or containing long chains of `if-else` conditions.

ğŸ§© However, donâ€™t apply OCP  **too early** .

Premature abstraction can make the code unnecessarily complex and confusing.

---

## âš ï¸ Common Misconceptions about OCP

| Misconception                                      | Reality                                                                                        |
| -------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| **â€œCode should never change again.â€**      | OCP doesnâ€™t forbid change â€” it encourages*safe*change through extension, not modification. |
| **â€œIt creates too many classes.â€**         | True, but modular classes improve scalability and maintainability.                             |
| **â€œIt makes code harder to read.â€**        | In small apps, yes. But in large systems, modularity simplifies understanding.                 |
| **â€œOCP should always be applied.â€**        | Apply it when the need for extensibility is clear, not prematurely.                            |
| **â€œRefactoring violates OCP.â€**            | Refactoring actually helps achieve OCP by restructuring code for extension.                    |
| **â€œNo testing is needed for extensions.â€** | Extensions still require testing â€” OCP just helps isolate them from breaking existing code.   |

---

## ğŸ§­ Summary

| Aspect                 | Description                                           |
| ---------------------- | ----------------------------------------------------- |
| **Principle**    | Open for Extension, Closed for Modification           |
| **Goal**         | Add new functionality without altering existing code  |
| **Pattern Used** | Strategy / Dependency Injection                       |
| **Benefits**     | Safer extensions, modular design, easier testing      |
| **Trade-Off**    | More classes and interfaces, but cleaner architecture |

---

## ğŸ§© Concept Diagram

<pre class="overflow-visible!" data-start="6830" data-end="7352"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"><span><span>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Invoice              â”‚
â”‚   (uses TaxCalculator)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚         Interface         â”‚
 â”‚      TaxCalculator        â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   IndiaTaxCalculator     â”‚
 â”‚   USTaxCalculator        â”‚
 â”‚   UKTaxCalculator        â”‚
 â”‚   GermanyTaxCalculator   â”‚  â† Added later without changing existing code
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span></code></div></div></pre>

Each new tax rule extends the system without rewriting the existing logic.

---

## ğŸ§¾ Final Thought

The **Open/Closed Principle** is about  **future-proofing your code** .

It helps you build systems that **evolve gracefully** â€” where adding new behavior doesnâ€™t break old ones.

If **Single Responsibility Principle** gives you focused classes,

**OCP** gives you **stable yet extensible systems** â€” the kind of design philosophy that large-scale platforms like Google and Amazon thrive on.
