# üîí Open/Closed Principle (OCP)

## üìò Introduction

The **Open/Closed Principle (OCP)** is the second principle in the **SOLID** set ‚Äî five core guidelines for writing  **clean, scalable, and maintainable object-oriented code** .

> **O** stands for  **Open for Extension, Closed for Modification** .

This means your classes, modules, and functions should allow  **new functionality to be added without changing existing code** .

In short: extend behavior, don‚Äôt rewrite it.

---

## üß© Definition

> **Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.**

The idea is to **minimize the risk of breaking existing functionality** when new features or rules are introduced.

---

## üîå Real-Life Analogy

Imagine you travel from **India** to the  **UK** .

Your Indian phone charger doesn‚Äôt fit the UK power socket.

Instead of **modifying** the charger, you simply use a  **travel adapter** .

‚úÖ The adapter **extends** the charger‚Äôs usability.

‚ùå You didn‚Äôt have to **change** the charger itself.

That‚Äôs exactly how OCP works in code ‚Äî you extend functionality through  **extension (adapters, subclasses, strategies)** , not modification.

---

## üíº Real-World Example ‚Äî Region-Based Tax Calculation

Let‚Äôs say we have an **Invoicing System** that calculates regional taxes:

| Region | Tax Type  | Rate |
| ------ | --------- | ---- |
| India  | GST       | 18%  |
| US     | Sales Tax | 8%   |
| UK     | VAT       | 12%  |

As the business grows, new regions (like Germany or Japan) might be added.

---

### ‚ùå Bad Design ‚Äî Violating OCP

<pre class="overflow-visible!" data-start="1830" data-end="2303"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>InvoiceProcessor</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTotal</span><span>(String region, double</span><span> amount) {
        </span><span>if</span><span> (region.equalsIgnoreCase(</span><span>"India"</span><span>)) {
            </span><span>return</span><span> amount + amount * </span><span>0.18</span><span>;
        } </span><span>else</span><span></span><span>if</span><span> (region.equalsIgnoreCase(</span><span>"US"</span><span>)) {
            </span><span>return</span><span> amount + amount * </span><span>0.08</span><span>;
        } </span><span>else</span><span></span><span>if</span><span> (region.equalsIgnoreCase(</span><span>"UK"</span><span>)) {
            </span><span>return</span><span> amount + amount * </span><span>0.12</span><span>;
        } </span><span>else</span><span> {
            </span><span>return</span><span> amount; </span><span>// No tax for unknown region</span><span>
        }
    }
}
</span></span></code></div></div></pre>

**Problems:**

* Adding a new region (e.g., Germany) means **editing** this class.
* High risk of breaking tested code.
* Hard to test and scale.
* Violates the  **Open/Closed Principle** .

---

### ‚úÖ Good Design ‚Äî Following OCP

We‚Äôll use **interfaces** and **dependency injection** to make this design extensible.

<pre class="overflow-visible!" data-start="2628" data-end="4166"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>// Tax Strategy Interface</span><span>
</span><span>interface</span><span></span><span>TaxCalculator</span><span> {
    </span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount);
}

</span><span>// Implementing Region-Specific Tax Calculators</span><span>
</span><span>class</span><span></span><span>IndiaTaxCalculator</span><span></span><span>implements</span><span></span><span>TaxCalculator</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount) {
        </span><span>return</span><span> amount * </span><span>0.18</span><span>; </span><span>// GST</span><span>
    }
}

</span><span>class</span><span></span><span>USTaxCalculator</span><span></span><span>implements</span><span></span><span>TaxCalculator</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount) {
        </span><span>return</span><span> amount * </span><span>0.08</span><span>; </span><span>// Sales Tax</span><span>
    }
}

</span><span>class</span><span></span><span>UKTaxCalculator</span><span></span><span>implements</span><span></span><span>TaxCalculator</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount) {
        </span><span>return</span><span> amount * </span><span>0.12</span><span>; </span><span>// VAT</span><span>
    }
}

</span><span>// Invoice Class using Dependency Injection</span><span>
</span><span>class</span><span></span><span>Invoice</span><span> {
    </span><span>private</span><span></span><span>double</span><span> amount;
    </span><span>private</span><span> TaxCalculator taxCalculator;

    </span><span>public</span><span></span><span>Invoice</span><span>(double</span><span> amount, TaxCalculator taxCalculator) {
        </span><span>this</span><span>.amount = amount;
        </span><span>this</span><span>.taxCalculator = taxCalculator;
    }

    </span><span>public</span><span></span><span>double</span><span></span><span>getTotalAmount</span><span>()</span><span> {
        </span><span>return</span><span> amount + taxCalculator.calculateTax(amount);
    }
}

</span><span>// Main Class</span><span>
</span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>double</span><span></span><span>amount</span><span></span><span>=</span><span></span><span>1000.0</span><span>;

        </span><span>Invoice</span><span></span><span>indiaInvoice</span><span></span><span>=</span><span></span><span>new</span><span></span><span>Invoice</span><span>(amount, </span><span>new</span><span></span><span>IndiaTaxCalculator</span><span>());
        System.out.println(</span><span>"Total (India): ‚Çπ"</span><span> + indiaInvoice.getTotalAmount());

        </span><span>Invoice</span><span></span><span>usInvoice</span><span></span><span>=</span><span></span><span>new</span><span></span><span>Invoice</span><span>(amount, </span><span>new</span><span></span><span>USTaxCalculator</span><span>());
        System.out.println(</span><span>"Total (US): $"</span><span> + usInvoice.getTotalAmount());

        </span><span>Invoice</span><span></span><span>ukInvoice</span><span></span><span>=</span><span></span><span>new</span><span></span><span>Invoice</span><span>(amount, </span><span>new</span><span></span><span>UKTaxCalculator</span><span>());
        System.out.println(</span><span>"Total (UK): ¬£"</span><span> + ukInvoice.getTotalAmount());
    }
}
</span></span></code></div></div></pre>

---

### üß† Explanation

* **Tax Strategy Interface:**

  Defines a common contract for all region-specific tax calculators.
* **Concrete Implementations:**

  Each region implements its own `TaxCalculator`, encapsulating its tax logic.
* **Dependency Injection:**

  The `Invoice` class depends on the `TaxCalculator` abstraction, not a specific implementation.
* **Extensibility:**

  To add a new region (e.g., Germany), simply create:

<pre class="overflow-visible!" data-start="4623" data-end="4774"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>GermanyTaxCalculator</span><span></span><span>implements</span><span></span><span>TaxCalculator</span><span> {
    </span><span>public</span><span></span><span>double</span><span></span><span>calculateTax</span><span>(double</span><span> amount) {
        </span><span>return</span><span> amount * </span><span>0.15</span><span>;
    }
}
</span></span></code></div></div></pre>

Then inject it:

<pre class="overflow-visible!" data-start="4792" data-end="4877"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>Invoice</span><span></span><span>germanyInvoice</span><span></span><span>=</span><span></span><span>new</span><span></span><span>Invoice</span><span>(amount, </span><span>new</span><span></span><span>GermanyTaxCalculator</span><span>());
</span></span></code></div></div></pre>

No existing code needs to change. That‚Äôs OCP in action.

---

## üß∞ When to Apply OCP

Use the **Open/Closed Principle** when:

* A module‚Äôs behavior is expected to **evolve** frequently.
* You need to **extend functionality** without touching stable, tested code.
* Building **frameworks or plugin-based systems** (e.g., billing engines, tax systems, UI modules).
* Preventing **regression bugs** in production-ready components.
* You notice a **‚ÄúGod Class‚Äù** ‚Äî a class doing too many things or containing long chains of `if-else` conditions.

üß© However, don‚Äôt apply OCP  **too early** .

Premature abstraction can make the code unnecessarily complex and confusing.

---

## ‚ö†Ô∏è Common Misconceptions about OCP

| Misconception                                      | Reality                                                                                        |
| -------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| **‚ÄúCode should never change again.‚Äù**      | OCP doesn‚Äôt forbid change ‚Äî it encourages*safe*change through extension, not modification. |
| **‚ÄúIt creates too many classes.‚Äù**         | True, but modular classes improve scalability and maintainability.                             |
| **‚ÄúIt makes code harder to read.‚Äù**        | In small apps, yes. But in large systems, modularity simplifies understanding.                 |
| **‚ÄúOCP should always be applied.‚Äù**        | Apply it when the need for extensibility is clear, not prematurely.                            |
| **‚ÄúRefactoring violates OCP.‚Äù**            | Refactoring actually helps achieve OCP by restructuring code for extension.                    |
| **‚ÄúNo testing is needed for extensions.‚Äù** | Extensions still require testing ‚Äî OCP just helps isolate them from breaking existing code.   |

---

## üß≠ Summary

| Aspect                 | Description                                           |
| ---------------------- | ----------------------------------------------------- |
| **Principle**    | Open for Extension, Closed for Modification           |
| **Goal**         | Add new functionality without altering existing code  |
| **Pattern Used** | Strategy / Dependency Injection                       |
| **Benefits**     | Safer extensions, modular design, easier testing      |
| **Trade-Off**    | More classes and interfaces, but cleaner architecture |

---

## üß© Concept Diagram

<pre class="overflow-visible!" data-start="6830" data-end="7352"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"><span><span>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          Invoice              ‚îÇ
‚îÇ   (uses TaxCalculator)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ         Interface         ‚îÇ
 ‚îÇ      TaxCalculator        ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ   IndiaTaxCalculator     ‚îÇ
 ‚îÇ   USTaxCalculator        ‚îÇ
 ‚îÇ   UKTaxCalculator        ‚îÇ
 ‚îÇ   GermanyTaxCalculator   ‚îÇ  ‚Üê Added later without changing existing code
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</span></span></code></div></div></pre>

Each new tax rule extends the system without rewriting the existing logic.

---

## üßæ Final Thought

The **Open/Closed Principle** is about  **future-proofing your code** .

It helps you build systems that **evolve gracefully** ‚Äî where adding new behavior doesn‚Äôt break old ones.

If **Single Responsibility Principle** gives you focused classes,

**OCP** gives you **stable yet extensible systems** ‚Äî the kind of design philosophy that large-scale platforms like Google and Amazon thrive on.
