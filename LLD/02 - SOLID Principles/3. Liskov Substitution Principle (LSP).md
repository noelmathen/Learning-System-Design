# ğŸ” Liskov Substitution Principle (LSP)

## ğŸ“˜ Introduction

The **Liskov Substitution Principle (LSP)** is the third principle in the **SOLID** framework â€” a set of five core principles for writing **clean, scalable, and maintainable** object-oriented code.

> **L** stands for  **Liskov Substitution Principle** .

---

## ğŸ§© Definition

> **If S is a subtype of T, then objects of type T may be replaced with objects of type S without altering the correctness of the program.**

In simple terms,  **a subclass should behave in a way that doesnâ€™t break the expectations of the parent class** .

If a child class changes the behavior so much that existing code breaks, it violates LSP.

---

## ğŸ§  Intuitive Example

If your code works fine using a parent class object, it should **still work** if you use a child class object instead â€” without surprises or unexpected results.

For example, if your code expects a `Shape` and you pass in a `Circle`, everything should still work normally.

If the subclass **changes assumptions** made by the parent (e.g., changes how width or height behaves), thatâ€™s an  **LSP violation** .

---

## ğŸ¾ Real-Life Analogy

Imagine you run a **pet hotel** with these basic rules:

> Every pet must be able to be  **fed** ,  **walked** , and  **groomed** .

Youâ€™ve had  **dogs** ,  **cats** , and **rabbits** stay â€” all fine.

Now someone brings in a **snake** ğŸ:

| Expected Action    | Works for Snake? | Problem         |
| ------------------ | ---------------- | --------------- |
| Feed with pet food | âŒ               | Needs live mice |
| Walk the pet       | âŒ               | Doesnâ€™t walk   |
| Groom the pet      | âŒ               | Makes no sense  |

Your pet hotel system just **broke** â€” the snake violates the expected behavior of â€œpets.â€

Thatâ€™s an  **LSP violation** .

âœ… A  **hamster** , on the other hand, might not walk outdoors but still fits the â€œpetâ€ contract â€” it can be cared for and fed.

Thatâ€™s  **valid substitution** .

---

## ğŸ’¡ Understanding the Principle

The **Pet Hotel** trusts that every "Pet" behaves in predictable ways.

If a new Pet (subclass) completely changes that, your whole system becomes fragile.

LSP ensures that **replacing a parent class with a subclass never breaks your programâ€™s logic.**

---

## âš ï¸ Example â€” Rectangle vs Square (LSP Violation)

A classic example demonstrating how easily LSP can be broken.

<pre class="overflow-visible!" data-start="2527" data-end="3365"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>// Rectangle class</span><span>
</span><span>class</span><span></span><span>Rectangle</span><span> {
    </span><span>int</span><span> width, height;

    </span><span>void</span><span></span><span>setWidth</span><span>(int</span><span> w) { width = w; }
    </span><span>void</span><span></span><span>setHeight</span><span>(int</span><span> h) { height = h; }
    </span><span>int</span><span></span><span>getArea</span><span>()</span><span> { </span><span>return</span><span> width * height; }
}

</span><span>// Square class extending Rectangle</span><span>
</span><span>class</span><span></span><span>Square</span><span></span><span>extends</span><span></span><span>Rectangle</span><span> {
    </span><span>@Override</span><span> 
    </span><span>void</span><span></span><span>setWidth</span><span>(int</span><span> w) {
        width = w;
        height = w; </span><span>// Forces both to be equal</span><span>
    }

    </span><span>@Override</span><span>
    </span><span>void</span><span></span><span>setHeight</span><span>(int</span><span> h) {
        height = h;
        width = h; </span><span>// Forces both to be equal</span><span>
    }
}

</span><span>// Main class</span><span>
</span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>Rectangle</span><span></span><span>r</span><span></span><span>=</span><span></span><span>new</span><span></span><span>Square</span><span>(); </span><span>// Substituting subclass</span><span>
        printArea(r);
    }

    </span><span>private</span><span></span><span>static</span><span></span><span>void</span><span></span><span>printArea</span><span>(Rectangle r)</span><span> {
        r.setWidth(</span><span>5</span><span>);
        r.setHeight(</span><span>10</span><span>);
        System.out.println(r.getArea()); </span><span>// Expected 50, Actual 100</span><span>
    }
}
</span></span></code></div></div></pre>

---

### âŒ Violation Explained

* **Expected Output:** 50
* **Actual Output:** 100

The **Square** changes how `setWidth` and `setHeight` work â€” breaking the expected behavior of `Rectangle`.

So `Square` **is not a true subtype** of `Rectangle`.

Thatâ€™s an  **LSP violation** .

---

## âœ… Need for LSP â€” Example: Notification System

Letâ€™s look at a valid substitution example.

<pre class="overflow-visible!" data-start="3755" data-end="4467"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>// Base class</span><span>
</span><span>class</span><span></span><span>Notification</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>sendNotification</span><span>()</span><span> {
        System.out.println(</span><span>"Notification sent"</span><span>);
    }
}

</span><span>// Email Notification</span><span>
</span><span>class</span><span></span><span>EmailNotification</span><span></span><span>extends</span><span></span><span>Notification</span><span> {
    </span><span>@Override</span><span>
    </span><span>public</span><span></span><span>void</span><span></span><span>sendNotification</span><span>()</span><span> {
        System.out.println(</span><span>"Email Notification sent"</span><span>);
    }
}

</span><span>// Text Notification</span><span>
</span><span>class</span><span></span><span>TextNotification</span><span></span><span>extends</span><span></span><span>Notification</span><span> {
    </span><span>@Override</span><span>
    </span><span>public</span><span></span><span>void</span><span></span><span>sendNotification</span><span>()</span><span> {
        System.out.println(</span><span>"Text Notification sent"</span><span>);
    }
}

</span><span>// Main</span><span>
</span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>Notification</span><span></span><span>notification</span><span></span><span>=</span><span></span><span>new</span><span></span><span>EmailNotification</span><span>(); </span><span>// Substitution</span><span>
        notification.sendNotification(); </span><span>// Works fine</span><span>
    }
}
</span></span></code></div></div></pre>

---

### ğŸ§  Explanation

* **Parent Class:** `Notification` defines a standard behavior.
* **Child Classes:** `EmailNotification` and `TextNotification` extend it  **without changing expected behavior** .
* **Result:** We can replace `Notification` with any subclass, and the system works perfectly.

Thatâ€™s proper use of **LSP** â€” extend functionality safely, without breaking the system.

---

## ğŸ§© Why LSP Matters

When LSP is  **violated** , the system becomes:

| Problem                    | Description                                            |
| -------------------------- | ------------------------------------------------------ |
| **Unpredictable**    | Base class assumptions no longer hold.                 |
| **Hard to Maintain** | Every new subclass needs re-testing across the system. |
| **Bug-Prone**        | Wrong results, runtime errors, or inconsistent state.  |
| **Less Reusable**    | Substitution becomes dangerous.                        |
| **Tightly Coupled**  | Client code depends on specific subclass behavior.     |

LSP ensures that your code remains  **robust, predictable, and easy to extend** .

---

## ğŸ” How to Spot LSP Violations

Ask yourself these questions:

* Does the subclass override methods in a way that changes their meaning?
* Can I replace the parent with the subclass everywhere  **without breaking anything** ?
* Does the subclass throw **unexpected exceptions** or return  **wrong values** ?
* Does the subclass weaken preconditions or strengthen postconditions?

If you answer **â€œyesâ€** to any of these â€” you likely have an  **LSP violation** .

---

## ğŸ§­ Key Guidelines to Follow

âœ… **Honor the Parent Contract:**

Subclasses must fulfill the promises of the parent class â€” not redefine them.

âœ… **Avoid Behavior Changes:**

Overridden methods should not alter how the class is expected to work.

âœ… **Prefer Composition over Inheritance:**

If subclassing forces you to violate behavior, use **composition** instead.

âœ… **Design for Behavioral Compatibility:**

Focus on  *what the object does* , not  *how it does it* .

âœ… **Extend, Donâ€™t Restrict:**

A subclass should **extend** functionality, not **limit** it.

---

## ğŸ§± Concept Diagram

<pre class="overflow-visible!" data-start="6516" data-end="6956"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"><span><span>          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚     Notification     â”‚
          â”‚  sendNotification()  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ EmailNotification â”‚     â”‚ TextNotification â”‚
â”‚ sendNotification() â”‚     â”‚ sendNotification() â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span></code></div></div></pre>

All subclasses **respect** the behavior of the parent class and can replace it safely.

---

## ğŸ§¾ Summary

| Aspect                  | Description                                               |
| ----------------------- | --------------------------------------------------------- |
| **Principle**     | Subclasses must be substitutable for their parent classes |
| **Goal**          | Maintain behavioral consistency when extending code       |
| **When Violated** | When subclass breaks expectations or base logic           |
| **Fix**           | Use composition or redesign contracts                     |
| **Result**        | Stable, extensible, and maintainable systems              |

---

## ğŸ§  Final Thought

The **Liskov Substitution Principle** is what keeps your inheritance trees  **logical and predictable** .

It ensures that extending functionality doesnâ€™t come at the cost of stability.

> If your subclass surprises the parent class â€” youâ€™ve broken trust.
>
> And in software,  **trust = maintainability** .
