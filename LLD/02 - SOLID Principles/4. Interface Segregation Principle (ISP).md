# ğŸ§© Interface Segregation Principle (ISP)

## ğŸ“˜ Introduction

The **Interface Segregation Principle (ISP)** is the fourth principle in the **SOLID** design philosophy â€” a set of five core guidelines for writing **clean, scalable, and maintainable** object-oriented code.

> **I** stands for  **Interface Segregation Principle** .

Before diving in, make sure you understand how **interfaces** work in Java.

You can refer to:

ğŸ‘‰ *[Interfaces in Java](#)* (insert your link or internal reference).

---

## ğŸ§  Definition

> **â€œDonâ€™t force a class to depend on methods it does not use.â€**

In simple terms, classes should  **only implement what they actually need** .

If a class is forced to implement irrelevant methods, it bloats the code, increases coupling, and breaks modularity.

---

## ğŸš— Understanding the Principle

Imagine using  **Uber** .

As a  **rider** , you only care about:

* Booking rides
* Tracking the driver
* Paying and rating the driver

But if the app showed you **driver** features like â€œaccept rideâ€ or â€œtrack earnings,â€ it would be a confusing mess.

Thatâ€™s what happens when a single interface tries to do too much â€” it forces classes to deal with methods irrelevant to them.

The **Interface Segregation Principle** prevents this by ensuring each interface serves a  **specific role** .

---

## ğŸ’¡ Uber Example: Applying ISP

### âŒ Bad Interface Design â€” Violates ISP

<pre class="overflow-visible!" data-start="1647" data-end="1800"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>interface</span><span></span><span>UberUser</span><span> {
    </span><span>void</span><span></span><span>bookRide</span><span>()</span><span>;
    </span><span>void</span><span></span><span>acceptRide</span><span>()</span><span>;
    </span><span>void</span><span></span><span>trackEarnings</span><span>()</span><span>;
    </span><span>void</span><span></span><span>ratePassenger</span><span>()</span><span>;
    </span><span>void</span><span></span><span>rateDriver</span><span>()</span><span>;
}
</span></span></code></div></div></pre>

This single interface tries to represent  **both riders and drivers** .

As a result, it forces classes to implement unnecessary methods.

<pre class="overflow-visible!" data-start="1940" data-end="2233"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>Rider</span><span></span><span>implements</span><span></span><span>UberUser</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>bookRide</span><span>()</span><span> { </span><span>/* needed */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>acceptRide</span><span>()</span><span> { </span><span>/* not needed */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>trackEarnings</span><span>()</span><span> { </span><span>/* not needed */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>ratePassenger</span><span>()</span><span> { </span><span>/* not needed */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>rateDriver</span><span>()</span><span> { </span><span>/* needed */</span><span> }
}
</span></span></code></div></div></pre>

ğŸ§¯ **Problem:**

* The `Rider` class is bloated with irrelevant methods.
* Future developers might misuse or accidentally override them.
* The design violates the  **Interface Segregation Principle** .

---

### âœ… Good Interface Design â€” Follows ISP

Split the large interface into smaller, **role-specific** ones.

<pre class="overflow-visible!" data-start="2556" data-end="2746"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>interface</span><span></span><span>RiderInterface</span><span> {
    </span><span>void</span><span></span><span>bookRide</span><span>()</span><span>;
    </span><span>void</span><span></span><span>rateDriver</span><span>()</span><span>;
}

</span><span>interface</span><span></span><span>DriverInterface</span><span> {
    </span><span>void</span><span></span><span>acceptRide</span><span>()</span><span>;
    </span><span>void</span><span></span><span>trackEarnings</span><span>()</span><span>;
    </span><span>void</span><span></span><span>ratePassenger</span><span>()</span><span>;
}
</span></span></code></div></div></pre>

Now, each class only depends on what it actually uses.

<pre class="overflow-visible!" data-start="2804" data-end="3121"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>Rider</span><span></span><span>implements</span><span></span><span>RiderInterface</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>bookRide</span><span>()</span><span> { </span><span>/* yes */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>rateDriver</span><span>()</span><span> { </span><span>/* yes */</span><span> }
}

</span><span>class</span><span></span><span>Driver</span><span></span><span>implements</span><span></span><span>DriverInterface</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>acceptRide</span><span>()</span><span> { </span><span>/* yes */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>trackEarnings</span><span>()</span><span> { </span><span>/* yes */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>ratePassenger</span><span>()</span><span> { </span><span>/* yes */</span><span> }
}
</span></span></code></div></div></pre>

ğŸ¯ **Result:**

* Each interface is focused and minimal.
* Each class implements **only** the behavior it needs.
* The codebase becomes  **cleaner, more modular, and easier to maintain** .

---

## ğŸ§© Benefits of Using ISP

| Benefit                        | Description                                                           |
| ------------------------------ | --------------------------------------------------------------------- |
| **Cleaner Codebase**     | Classes no longer have to deal with irrelevant methods.               |
| **Better Flexibility**   | Changes in one interface donâ€™t affect unrelated classes.             |
| **High Maintainability** | Smaller interfaces are easier to understand, implement, and test.     |
| **Fewer Bugs**           | Reduced risk of misusing or accidentally overriding unwanted methods. |
| **Improved Scalability** | New roles (e.g., delivery partners in Uber Eats) can be added easily. |

---

## âš™ï¸ When to Apply ISP

You should consider applying the **Interface Segregation Principle** when:

* ğŸ” A class is implementing methods it doesnâ€™t use.
* ğŸ’¥ An interface starts becoming â€œfatâ€ â€” too many unrelated methods.
* ğŸ”„ Adding a new feature forces changes in unrelated classes.
* ğŸŒ Youâ€™re designing APIs or plugins â€” exposing only relevant methods improves usability and safety.

> The best interfaces are  **small, focused, and meaningful** .

---

## ğŸ§­ Key Takeaways

| Principle              | Meaning                                               |
| ---------------------- | ----------------------------------------------------- |
| **ISP**          | Donâ€™t make clients depend on methods they donâ€™t use |
| **Goal**         | Create smaller, role-specific interfaces              |
| **Prevents**     | Bloated â€œfatâ€ interfaces                            |
| **Improves**     | Decoupling, readability, maintainability              |
| **Applied Best** | When designing extensible, scalable APIs and systems  |

---

## ğŸ§° Visual Summary

<pre class="overflow-visible!" data-start="4742" data-end="5264"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"><span><span>          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚        UberUser          â”‚ âŒ (Too many methods)
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚          â”‚
               â–¼          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ RiderInterface â”‚   â”‚ DriverInterface  â”‚ âœ… (Focused interfaces)
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                     â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚     Rider     â”‚     â”‚    Driver    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span></code></div></div></pre>

---

## ğŸ§¾ Conclusion

The **Interface Segregation Principle** ensures that your interfaces remain  **small, focused, and client-specific** .

It keeps your code **modular, testable, and future-proof** â€” just like how Uber separates **driver** and **rider** experiences for clarity.

> ğŸ§  **Remember:**
>
> Fat interfaces = confusion.
>
> Slim, purpose-specific interfaces = clean architecture.
>
