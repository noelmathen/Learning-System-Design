# 🧩 Interface Segregation Principle (ISP)

## 📘 Introduction

The **Interface Segregation Principle (ISP)** is the fourth principle in the **SOLID** design philosophy — a set of five core guidelines for writing **clean, scalable, and maintainable** object-oriented code.

> **I** stands for  **Interface Segregation Principle** .

Before diving in, make sure you understand how **interfaces** work in Java.

You can refer to:

👉 *[Interfaces in Java](#)* (insert your link or internal reference).

---

## 🧠 Definition

> **“Don’t force a class to depend on methods it does not use.”**

In simple terms, classes should  **only implement what they actually need** .

If a class is forced to implement irrelevant methods, it bloats the code, increases coupling, and breaks modularity.

---

## 🚗 Understanding the Principle

Imagine using  **Uber** .

As a  **rider** , you only care about:

* Booking rides
* Tracking the driver
* Paying and rating the driver

But if the app showed you **driver** features like “accept ride” or “track earnings,” it would be a confusing mess.

That’s what happens when a single interface tries to do too much — it forces classes to deal with methods irrelevant to them.

The **Interface Segregation Principle** prevents this by ensuring each interface serves a  **specific role** .

---

## 💡 Uber Example: Applying ISP

### ❌ Bad Interface Design — Violates ISP

<pre class="overflow-visible!" data-start="1647" data-end="1800"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>interface</span><span></span><span>UberUser</span><span> {
    </span><span>void</span><span></span><span>bookRide</span><span>()</span><span>;
    </span><span>void</span><span></span><span>acceptRide</span><span>()</span><span>;
    </span><span>void</span><span></span><span>trackEarnings</span><span>()</span><span>;
    </span><span>void</span><span></span><span>ratePassenger</span><span>()</span><span>;
    </span><span>void</span><span></span><span>rateDriver</span><span>()</span><span>;
}
</span></span></code></div></div></pre>

This single interface tries to represent  **both riders and drivers** .

As a result, it forces classes to implement unnecessary methods.

<pre class="overflow-visible!" data-start="1940" data-end="2233"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>Rider</span><span></span><span>implements</span><span></span><span>UberUser</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>bookRide</span><span>()</span><span> { </span><span>/* needed */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>acceptRide</span><span>()</span><span> { </span><span>/* not needed */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>trackEarnings</span><span>()</span><span> { </span><span>/* not needed */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>ratePassenger</span><span>()</span><span> { </span><span>/* not needed */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>rateDriver</span><span>()</span><span> { </span><span>/* needed */</span><span> }
}
</span></span></code></div></div></pre>

🧯 **Problem:**

* The `Rider` class is bloated with irrelevant methods.
* Future developers might misuse or accidentally override them.
* The design violates the  **Interface Segregation Principle** .

---

### ✅ Good Interface Design — Follows ISP

Split the large interface into smaller, **role-specific** ones.

<pre class="overflow-visible!" data-start="2556" data-end="2746"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>interface</span><span></span><span>RiderInterface</span><span> {
    </span><span>void</span><span></span><span>bookRide</span><span>()</span><span>;
    </span><span>void</span><span></span><span>rateDriver</span><span>()</span><span>;
}

</span><span>interface</span><span></span><span>DriverInterface</span><span> {
    </span><span>void</span><span></span><span>acceptRide</span><span>()</span><span>;
    </span><span>void</span><span></span><span>trackEarnings</span><span>()</span><span>;
    </span><span>void</span><span></span><span>ratePassenger</span><span>()</span><span>;
}
</span></span></code></div></div></pre>

Now, each class only depends on what it actually uses.

<pre class="overflow-visible!" data-start="2804" data-end="3121"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>Rider</span><span></span><span>implements</span><span></span><span>RiderInterface</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>bookRide</span><span>()</span><span> { </span><span>/* yes */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>rateDriver</span><span>()</span><span> { </span><span>/* yes */</span><span> }
}

</span><span>class</span><span></span><span>Driver</span><span></span><span>implements</span><span></span><span>DriverInterface</span><span> {
    </span><span>public</span><span></span><span>void</span><span></span><span>acceptRide</span><span>()</span><span> { </span><span>/* yes */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>trackEarnings</span><span>()</span><span> { </span><span>/* yes */</span><span> }
    </span><span>public</span><span></span><span>void</span><span></span><span>ratePassenger</span><span>()</span><span> { </span><span>/* yes */</span><span> }
}
</span></span></code></div></div></pre>

🎯 **Result:**

* Each interface is focused and minimal.
* Each class implements **only** the behavior it needs.
* The codebase becomes  **cleaner, more modular, and easier to maintain** .

---

## 🧩 Benefits of Using ISP

| Benefit                        | Description                                                           |
| ------------------------------ | --------------------------------------------------------------------- |
| **Cleaner Codebase**     | Classes no longer have to deal with irrelevant methods.               |
| **Better Flexibility**   | Changes in one interface don’t affect unrelated classes.             |
| **High Maintainability** | Smaller interfaces are easier to understand, implement, and test.     |
| **Fewer Bugs**           | Reduced risk of misusing or accidentally overriding unwanted methods. |
| **Improved Scalability** | New roles (e.g., delivery partners in Uber Eats) can be added easily. |

---

## ⚙️ When to Apply ISP

You should consider applying the **Interface Segregation Principle** when:

* 🔍 A class is implementing methods it doesn’t use.
* 💥 An interface starts becoming “fat” — too many unrelated methods.
* 🔄 Adding a new feature forces changes in unrelated classes.
* 🌐 You’re designing APIs or plugins — exposing only relevant methods improves usability and safety.

> The best interfaces are  **small, focused, and meaningful** .

---

## 🧭 Key Takeaways

| Principle              | Meaning                                               |
| ---------------------- | ----------------------------------------------------- |
| **ISP**          | Don’t make clients depend on methods they don’t use |
| **Goal**         | Create smaller, role-specific interfaces              |
| **Prevents**     | Bloated “fat” interfaces                            |
| **Improves**     | Decoupling, readability, maintainability              |
| **Applied Best** | When designing extensible, scalable APIs and systems  |

---

## 🧰 Visual Summary

<pre class="overflow-visible!" data-start="4742" data-end="5264"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-text"><span><span>          ┌──────────────────────────┐
          │        UberUser          │ ❌ (Too many methods)
          └──────────────────────────┘
               │          │
               ▼          ▼
   ┌────────────────┐   ┌──────────────────┐
   │ RiderInterface │   │ DriverInterface  │ ✅ (Focused interfaces)
   └────────────────┘   └──────────────────┘
         │                     │
   ┌───────────────┐     ┌──────────────┐
   │     Rider     │     │    Driver    │
   └───────────────┘     └──────────────┘
</span></span></code></div></div></pre>

---

## 🧾 Conclusion

The **Interface Segregation Principle** ensures that your interfaces remain  **small, focused, and client-specific** .

It keeps your code **modular, testable, and future-proof** — just like how Uber separates **driver** and **rider** experiences for clarity.

> 🧠 **Remember:**
>
> Fat interfaces = confusion.
>
> Slim, purpose-specific interfaces = clean architecture.
>
