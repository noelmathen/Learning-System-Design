# 🧩 Software Design Principles

Software design principles are timeless guidelines that help developers build systems that are  **easy to read, maintain, and extend** .

They serve as the invisible guardrails that prevent your codebase from collapsing under its own weight.

These principles apply at both **High-Level Design (HLD)** and **Low-Level Design (LLD)** stages — from system architecture down to the logic of a single class.

This section focuses on three core principles every engineer should tattoo on their brain:

* **DRY** — Don’t Repeat Yourself
* **KISS** — Keep It Simple, Stupid
* **YAGNI** — You Aren’t Gonna Need It

---

## 1. 🧠 DRY — Don’t Repeat Yourself

**Definition:**

The DRY principle means that  **each piece of knowledge or logic should exist in only one place** .

If you’re copying code, you’re creating future pain — because when one copy changes, the others won’t magically follow.

**Why it matters:**

* Reduces redundancy
* Simplifies maintenance
* Ensures consistency
* Promotes reusability

---

### 🚫 Bad Example — Repeated Logic

<pre class="overflow-visible!" data-start="1381" data-end="1693"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>public</span><span></span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>int</span><span></span><span>len1</span><span></span><span>=</span><span></span><span>12</span><span>, wid1 = </span><span>6</span><span>;
        </span><span>int</span><span></span><span>areaA</span><span></span><span>=</span><span> len1 * wid1;
        System.out.println(</span><span>"Area A: "</span><span> + areaA);

        </span><span>int</span><span></span><span>len2</span><span></span><span>=</span><span></span><span>9</span><span>, wid2 = </span><span>4</span><span>;
        </span><span>int</span><span></span><span>areaB</span><span></span><span>=</span><span> len2 * wid2;
        System.out.println(</span><span>"Area B: "</span><span> + areaB);
    }
}
</span></span></code></div></div></pre>

Here, the logic for calculating the area is repeated.

If the formula ever changes, you’ll have to hunt it down in multiple places — a bug waiting to happen.

---

### ✅ Good Example — Follow DRY

<pre class="overflow-visible!" data-start="1895" data-end="2298"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>RectangleUtils</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>int</span><span></span><span>findArea</span><span>(int</span><span> length, </span><span>int</span><span> width) {
        </span><span>return</span><span> length * width;
    }
}

</span><span>public</span><span></span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>int</span><span></span><span>areaA</span><span></span><span>=</span><span> RectangleUtils.findArea(</span><span>12</span><span>, </span><span>6</span><span>);
        </span><span>int</span><span></span><span>areaB</span><span></span><span>=</span><span> RectangleUtils.findArea(</span><span>9</span><span>, </span><span>4</span><span>);

        System.out.println(</span><span>"Area A: "</span><span> + areaA);
        System.out.println(</span><span>"Area B: "</span><span> + areaB);
    }
}
</span></span></code></div></div></pre>

Now, the logic lives in one place — `findArea()`.

If the formula changes, you fix it once and move on with life.

---

### 🧩 Applying DRY in Real Projects

* Identify and refactor **repeated logic** into a shared method or utility class.
* Use **inheritance** or **composition** when similar logic appears in multiple classes.
* Leverage frameworks and libraries — don’t reinvent the wheel.
* Regularly review code for **duplication creep** as features evolve.

---

### ⚠️ When *Not* to Apply DRY

Even good ideas can be overdone. Avoid DRY when:

* **Premature Abstraction:** Two code blocks look similar now but may evolve differently later.
* **Performance-Critical Code:** Sometimes, a small inline duplication is faster than method calls.
* **Readability Concerns:** If extracting logic makes the code harder to follow, clarity wins.
* **Legacy Code:** Don’t refactor fragile legacy systems unless it’s necessary and well-tested.

Remember: **DRY helps maintainability, not heroism.**

---

## 2. 🧾 KISS — Keep It Simple, Stupid

**Definition:**

The KISS principle reminds you that  **simplicity is strength** .

Overcomplicating logic, layering unnecessary abstractions, or “showing off” clever code usually backfires.

In other words: *Write code a tired teammate can understand at 2 AM.*

**Why it matters:**

* Easier debugging
* Cleaner readability
* Quicker onboarding
* Faster development

---

### 🚫 Bad Example — Overengineering

<pre class="overflow-visible!" data-start="3790" data-end="4045"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>public</span><span></span><span>class</span><span></span><span>NumberHelper</span><span> {

    </span><span>public</span><span></span><span>static</span><span></span><span>boolean</span><span></span><span>isEven</span><span>(int</span><span> n) {
        </span><span>boolean</span><span></span><span>result</span><span></span><span>=</span><span></span><span>false</span><span>;

        </span><span>if</span><span> (n % </span><span>2</span><span> == </span><span>0</span><span>) {
            result = </span><span>true</span><span>;
        } </span><span>else</span><span> {
            result = </span><span>false</span><span>;
        }

        </span><span>return</span><span> result;
    }
}
</span></span></code></div></div></pre>

Too many lines for something this trivial.

You’ve turned a one-liner into a drama.

---

### ✅ Good Example — Simplicity Wins

<pre class="overflow-visible!" data-start="4178" data-end="4295"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>public</span><span></span><span>class</span><span></span><span>NumberHelper</span><span> {

    </span><span>public</span><span></span><span>static</span><span></span><span>boolean</span><span></span><span>isEven</span><span>(int</span><span> n) {
        </span><span>return</span><span> n % </span><span>2</span><span> == </span><span>0</span><span>;
    }
}
</span></span></code></div></div></pre>

One line.

No wasted variables.

Perfectly readable.

---

### 💡 Applying KISS in Practice

* Avoid “smart” tricks when plain logic works.
* Don’t create abstraction layers unless they serve a real need.
* Always aim for  **clarity over cleverness** .
* Review your own code and ask: *Could this be simpler?*

---

## 3. 🚀 YAGNI — You Aren’t Gonna Need It

**Definition:**

Don’t build features “just in case.”

Implement functionality  **only when it’s actually needed** , not when you *imagine* it might be useful someday.

Every “future-proof” idea you add too early becomes technical debt tomorrow.

**Why it matters:**

* Reduces wasted effort
* Keeps code lightweight
* Shortens development cycles
* Prevents unnecessary complexity

---

### 🧠 Example

You’re asked to build a **note-taking app** with two features:

* Create a note
* View notes

Now your imagination kicks in:

“What if users want categories? Or hashtags? Or cloud sync? Maybe voice notes?”

You spend a week designing for features  **no one requested** , and by the time you’re done, the real requirements have changed.

---

### ⚙️ When YAGNI Might Not Apply

* **Guaranteed Upcoming Features:**

  If something is confirmed in the roadmap (e.g., “image attachments in 2 sprints”), designing your data model to handle it now could save rework later.
* **Performance-Critical Systems:**

  In highly optimized systems, thinking ahead for scaling and efficiency is valid.

Otherwise, don’t waste time polishing ghosts.

---

## 🧭 Summary

| Principle       | Meaning                           | Core Benefit                 |
| --------------- | --------------------------------- | ---------------------------- |
| **DRY**   | Don’t repeat code or logic       | Cleaner, maintainable code   |
| **KISS**  | Keep designs simple               | Easier to read and debug     |
| **YAGNI** | Don’t build unnecessary features | Reduces complexity and waste |

---

## 💬 Final Thoughts

Good design isn’t about stuffing your code with patterns and buzzwords.

It’s about **clarity, purpose, and restraint** — doing just enough, and doing it well.

These three principles —  **DRY** ,  **KISS** , and **YAGNI** — are the foundations of clean, elegant design.

Master them, and every interviewer from Google to Meta will see that you don’t just write code — you design it thoughtfully.
