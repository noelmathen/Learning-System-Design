# ğŸ§© Software Design Principles

Software design principles are timeless guidelines that help developers build systems that are  **easy to read, maintain, and extend** .

They serve as the invisible guardrails that prevent your codebase from collapsing under its own weight.

These principles apply at both **High-Level Design (HLD)** and **Low-Level Design (LLD)** stages â€” from system architecture down to the logic of a single class.

This section focuses on three core principles every engineer should tattoo on their brain:

* **DRY** â€” Donâ€™t Repeat Yourself
* **KISS** â€” Keep It Simple, Stupid
* **YAGNI** â€” You Arenâ€™t Gonna Need It

---

## 1. ğŸ§  DRY â€” Donâ€™t Repeat Yourself

**Definition:**

The DRY principle means that  **each piece of knowledge or logic should exist in only one place** .

If youâ€™re copying code, youâ€™re creating future pain â€” because when one copy changes, the others wonâ€™t magically follow.

**Why it matters:**

* Reduces redundancy
* Simplifies maintenance
* Ensures consistency
* Promotes reusability

---

### ğŸš« Bad Example â€” Repeated Logic

<pre class="overflow-visible!" data-start="1381" data-end="1693"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>public</span><span></span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>int</span><span></span><span>len1</span><span></span><span>=</span><span></span><span>12</span><span>, wid1 = </span><span>6</span><span>;
        </span><span>int</span><span></span><span>areaA</span><span></span><span>=</span><span> len1 * wid1;
        System.out.println(</span><span>"Area A: "</span><span> + areaA);

        </span><span>int</span><span></span><span>len2</span><span></span><span>=</span><span></span><span>9</span><span>, wid2 = </span><span>4</span><span>;
        </span><span>int</span><span></span><span>areaB</span><span></span><span>=</span><span> len2 * wid2;
        System.out.println(</span><span>"Area B: "</span><span> + areaB);
    }
}
</span></span></code></div></div></pre>

Here, the logic for calculating the area is repeated.

If the formula ever changes, youâ€™ll have to hunt it down in multiple places â€” a bug waiting to happen.

---

### âœ… Good Example â€” Follow DRY

<pre class="overflow-visible!" data-start="1895" data-end="2298"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>class</span><span></span><span>RectangleUtils</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>int</span><span></span><span>findArea</span><span>(int</span><span> length, </span><span>int</span><span> width) {
        </span><span>return</span><span> length * width;
    }
}

</span><span>public</span><span></span><span>class</span><span></span><span>Main</span><span> {
    </span><span>public</span><span></span><span>static</span><span></span><span>void</span><span></span><span>main</span><span>(String[] args)</span><span> {
        </span><span>int</span><span></span><span>areaA</span><span></span><span>=</span><span> RectangleUtils.findArea(</span><span>12</span><span>, </span><span>6</span><span>);
        </span><span>int</span><span></span><span>areaB</span><span></span><span>=</span><span> RectangleUtils.findArea(</span><span>9</span><span>, </span><span>4</span><span>);

        System.out.println(</span><span>"Area A: "</span><span> + areaA);
        System.out.println(</span><span>"Area B: "</span><span> + areaB);
    }
}
</span></span></code></div></div></pre>

Now, the logic lives in one place â€” `findArea()`.

If the formula changes, you fix it once and move on with life.

---

### ğŸ§© Applying DRY in Real Projects

* Identify and refactor **repeated logic** into a shared method or utility class.
* Use **inheritance** or **composition** when similar logic appears in multiple classes.
* Leverage frameworks and libraries â€” donâ€™t reinvent the wheel.
* Regularly review code for **duplication creep** as features evolve.

---

### âš ï¸ When *Not* to Apply DRY

Even good ideas can be overdone. Avoid DRY when:

* **Premature Abstraction:** Two code blocks look similar now but may evolve differently later.
* **Performance-Critical Code:** Sometimes, a small inline duplication is faster than method calls.
* **Readability Concerns:** If extracting logic makes the code harder to follow, clarity wins.
* **Legacy Code:** Donâ€™t refactor fragile legacy systems unless itâ€™s necessary and well-tested.

Remember: **DRY helps maintainability, not heroism.**

---

## 2. ğŸ§¾ KISS â€” Keep It Simple, Stupid

**Definition:**

The KISS principle reminds you that  **simplicity is strength** .

Overcomplicating logic, layering unnecessary abstractions, or â€œshowing offâ€ clever code usually backfires.

In other words: *Write code a tired teammate can understand at 2 AM.*

**Why it matters:**

* Easier debugging
* Cleaner readability
* Quicker onboarding
* Faster development

---

### ğŸš« Bad Example â€” Overengineering

<pre class="overflow-visible!" data-start="3790" data-end="4045"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>public</span><span></span><span>class</span><span></span><span>NumberHelper</span><span> {

    </span><span>public</span><span></span><span>static</span><span></span><span>boolean</span><span></span><span>isEven</span><span>(int</span><span> n) {
        </span><span>boolean</span><span></span><span>result</span><span></span><span>=</span><span></span><span>false</span><span>;

        </span><span>if</span><span> (n % </span><span>2</span><span> == </span><span>0</span><span>) {
            result = </span><span>true</span><span>;
        } </span><span>else</span><span> {
            result = </span><span>false</span><span>;
        }

        </span><span>return</span><span> result;
    }
}
</span></span></code></div></div></pre>

Too many lines for something this trivial.

Youâ€™ve turned a one-liner into a drama.

---

### âœ… Good Example â€” Simplicity Wins

<pre class="overflow-visible!" data-start="4178" data-end="4295"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-java"><span><span>public</span><span></span><span>class</span><span></span><span>NumberHelper</span><span> {

    </span><span>public</span><span></span><span>static</span><span></span><span>boolean</span><span></span><span>isEven</span><span>(int</span><span> n) {
        </span><span>return</span><span> n % </span><span>2</span><span> == </span><span>0</span><span>;
    }
}
</span></span></code></div></div></pre>

One line.

No wasted variables.

Perfectly readable.

---

### ğŸ’¡ Applying KISS in Practice

* Avoid â€œsmartâ€ tricks when plain logic works.
* Donâ€™t create abstraction layers unless they serve a real need.
* Always aim for  **clarity over cleverness** .
* Review your own code and ask: *Could this be simpler?*

---

## 3. ğŸš€ YAGNI â€” You Arenâ€™t Gonna Need It

**Definition:**

Donâ€™t build features â€œjust in case.â€

Implement functionality  **only when itâ€™s actually needed** , not when you *imagine* it might be useful someday.

Every â€œfuture-proofâ€ idea you add too early becomes technical debt tomorrow.

**Why it matters:**

* Reduces wasted effort
* Keeps code lightweight
* Shortens development cycles
* Prevents unnecessary complexity

---

### ğŸ§  Example

Youâ€™re asked to build a **note-taking app** with two features:

* Create a note
* View notes

Now your imagination kicks in:

â€œWhat if users want categories? Or hashtags? Or cloud sync? Maybe voice notes?â€

You spend a week designing for features  **no one requested** , and by the time youâ€™re done, the real requirements have changed.

---

### âš™ï¸ When YAGNI Might Not Apply

* **Guaranteed Upcoming Features:**

  If something is confirmed in the roadmap (e.g., â€œimage attachments in 2 sprintsâ€), designing your data model to handle it now could save rework later.
* **Performance-Critical Systems:**

  In highly optimized systems, thinking ahead for scaling and efficiency is valid.

Otherwise, donâ€™t waste time polishing ghosts.

---

## ğŸ§­ Summary

| Principle       | Meaning                           | Core Benefit                 |
| --------------- | --------------------------------- | ---------------------------- |
| **DRY**   | Donâ€™t repeat code or logic       | Cleaner, maintainable code   |
| **KISS**  | Keep designs simple               | Easier to read and debug     |
| **YAGNI** | Donâ€™t build unnecessary features | Reduces complexity and waste |

---

## ğŸ’¬ Final Thoughts

Good design isnâ€™t about stuffing your code with patterns and buzzwords.

Itâ€™s about **clarity, purpose, and restraint** â€” doing just enough, and doing it well.

These three principles â€”  **DRY** ,  **KISS** , and **YAGNI** â€” are the foundations of clean, elegant design.

Master them, and every interviewer from Google to Meta will see that you donâ€™t just write code â€” you design it thoughtfully.
